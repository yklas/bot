import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command, CommandStart
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from datetime import datetime
import pytz
import logging
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import random
from typing import List, Dict
import json 

# Configuration
TELEGRAM_TOKEN = "7819420348:AAHElDNd7JI4c5gDbYD7TTe2kAWVn2TVZBo"
TIMEZONE = pytz.timezone('Asia/Almaty')

# Logging setup with more detailed configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Initialize bot and dispatcher with error handling
bot = Bot(token=TELEGRAM_TOKEN)
dp = Dispatcher()

# Store active users and group chats with proper type hints
active_users: set[int] = set()
group_ids: set[int] = set()

# Add error handling decorator
def handle_exceptions(func):
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            logger.error(f"Error in {func.__name__}: {e}", exc_info=True)
            # Get chat_id from different possible argument types
            chat_id = None
            for arg in args:
                if isinstance(arg, Message):
                    chat_id = arg.chat.id
                elif isinstance(arg, CallbackQuery):
                    chat_id = arg.message.chat.id
                elif isinstance(arg, int):
                    chat_id = arg
            
            if chat_id:
                try:
                    await bot.send_message(
                        chat_id=chat_id,
                        text="าะฐัะตะปัะบ ะพััะฝ ะฐะปะดั. าะฐะนัะฐะดะฐะฝ ำัะตะบะตััะตะฝัะฟ ะบำฉััาฃัะท. /start"
                    )
                except Exception as send_error:
                    logger.error(f"Error sending error message: {send_error}")
    return wrapper


# English learning content
ENGLISH_QUESTIONS: List[Dict] = [
    {
        "id": "1",
        "image_url": "https://m.media-amazon.com/images/I/514nTHwlFnL.jpg",
        "question": "ะขะฐะผะฐา ััะบะตะฝ ะบะตะทะดะต าะพะปะดะฐะฝะฐััะฝ ะฑาฑะป ะทะฐั าะฐะปะฐะน ะฐัะฐะปะฐะดั?",
        "options": ["Spoon", "Fork", "Knife", "Plate"],
        "correct": "Spoon",
    },
    {
        "id": "2",
        "image_url": "https://www.kitchenstuffplus.com/media/catalog/product/7/3/7398_hauz-stovetop-kettle_230914133830626_ldk9f98hlpmd9nxf.jpg",
        "question": "ะั าฏะนะดะต ัั าะฐะนะฝะฐัั าฏััะฝ าะพะปะดะฐะฝะฐััะฝ าาฑััะปาั าะฐะปะฐะน ะฐัะฐะปะฐะดั?",
        "options": ["Kettle", "Toaster", "Blender", "Bucket"],
        "correct": "Kettle",
    },
    {
        "id": "3",
        "image_url": "https://www.oates.com.au/medias/VC-Prod-Sell-Slot-null?context=bWFzdGVyfHJvb3R8MTg3MjI4fGltYWdlL3BuZ3xhREpoTDJneU1TODVOVE0xTkRJM05ERXhPVGs0TDFaRFgxQnliMlJmVTJWc2JGOVRiRzkwWDI1MWJHd3w3ZmVkZTc0Y2QzMWU4ZjAxMmFiM2NlM2M4NDYxYjY0NzQyNTAyYTM0YjdkNDNiZmFlMjU3N2RiYmU3NWVkYjIw",
        "question": "าฎะนะดะตะณั ะตะดะตะฝะดั ัะฐะทะฐะปะฐั าฏััะฝ าะพะปะดะฐะฝะฐััะฝ ะฑาฑะป ะทะฐั าะฐะปะฐะน ะฐัะฐะปะฐะดั?",
        "options": ["Mop", "Broom", "Rug", "Bucket"],
        "correct": "Broom",
    },
    {
        "id": "4",
        "image_url": "https://www.thefurnituremarket.co.uk/media/catalog/product/cache/e87de9c08ea8cd93ad1e6aad80c8118c/r/c/rc15-cotswold-rustic-oak-double-wardrobe-1.jpg",
        "question": "ะะธัะผะดะตัะดั ะถะธะฝะฐะฟ, ัะฐาัะฐั าฏััะฝ าะพะปะดะฐะฝะฐััะฝ ะฑาฑะป ะทะฐั าะฐะปะฐะน ะฐัะฐะปะฐะดั?",
        "options": ["Sofa", "Mirror", "Wardrobe", "Table"],
        "correct": "Wardrobe",
    }
]

# Improve user progress tracking with TypedDict
from typing import TypedDict

class UserProgress(TypedDict):
    asked_questions: List[str]
    current_question: Dict | None
    correct_answers: int
    questions_answered: int
    last_question_message: Dict | None

user_progress: Dict[int, UserProgress] = {}
# Add rate limiting
from collections import defaultdict
from datetime import datetime, timedelta

rate_limit: Dict[int, List[datetime]] = defaultdict(list)
RATE_LIMIT_MESSAGES = 5
RATE_LIMIT_PERIOD = 60  # seconds

def is_rate_limited(user_id: int) -> bool:
    now = datetime.now()
    # Clean old timestamps
    rate_limit[user_id] = [ts for ts in rate_limit[user_id] 
                          if now - ts < timedelta(seconds=RATE_LIMIT_PERIOD)]
    
    if len(rate_limit[user_id]) >= RATE_LIMIT_MESSAGES:
        return True
    
    rate_limit[user_id].append(now)
    return False


# Basic responses dictionary
BASIC_RESPONSES = {
    "ัำะปะตะผ": "ัำะปะตะผ าะฐะปะฐะนััะท?",
    "ัะฐะปะตะผ": "ัะฐะปะตะผ าะฐะปะฐะนััะท?",
    "ัำะปะตะผ าะฐะปะฐะนััาฃ": "ะะปัะฐะผะดัะปะธะปะปะฐั, ะถะฐาัั! ำจะทัาฃัะท าะฐะปะฐะนััะท?",
    "าะฐะปะฐะนััาฃ": "ะะปัะฐะผะดัะปะธะปะปะฐั, ะถะฐาัั! ำจะทัาฃัะท าะฐะปะฐะนััะท?",
    "ัะฐัะผะตั": "าะพั ะบะตะปะดัาฃัะท! ๐",
    "ะฐััะฐะปะฐัะผะฐาะฐะปะตะนะบัะผ": "ะฃะฐาะฐะปะตะนะบัะผ ะฐััะฐะปะฐะผ! ๐ าะฐะปัาฃัะท าะฐะปะฐะน?",
    "ะฝะต ะถะฐาฃะฐะปัา": "ะถะฐาฃะฐะปัาัั ัััะฑัะฐะฝ าะฐัะฐัะฐาฃัะท ะฑะพะปะฐะดั ๐",
    "าะฐะนััะปั ัะฐาฃ": "าะฐะนััะปั ัะฐาฃ, ะฑะฐััะฐะผัะทาะฐ าะฐะนััะปั ะบาฏะฝ ะฑะพะปััะฝ! ๐ซ",
    "ะฝะตะณะต": "ะฑะฐะปาะฐ ะผะตะฝ ัะตะณะต ๐",
    "ะถะฐาััะผัะฝ": "ะถะฐาัั ะฑะพะปัะฐาฃ ะผะตะฝะดะต ะถะฐาััะผัะฝ ะฐะนะฝะฐะปะฐะนัะฝ!๐",
    "ััะฝัั ะพััั": "ะบะฐะทัั ะฑะพั ะพัััะฐััะฝ ะทะฐะผะฐะฝ ะตะผะตั ๐",
    "ะฑะฐััััะผ": "ะฑะฐััััะผ ัััะผะดะตะณั ัะฐััััะผ ะดะธัะฝะณะพ",
    "ะะฐะฐ": "ะะฐะฐ ะดะตะผะต ะขาฏััะฝัะบัั ะดะต",
    "ะะฐ": "ะะฐ ะดะตะผะต ะะฐะฐ ะดะตะฟ ะฐะนั",
    "ะถะฐาัั": "ะตะตะต ัะพะปะฐะน ะดะต",
    "ะาฏััั": "ะาฏััั ะดะตะผะต ะถะฐาัั ะดะต",
    "Good morning": "ำะฝั, ะฐาัะปััะฝัะฐ ะถัะฑะตัะตะดั ะดะธะผ",
    "๐": "ะบาฏะปะผะต ะดะพัาะฐ ะบะตะปะตั ะฑะฐัาะฐ ะดะตะนะดั ๐",
    "ะะฐัะฐะะปะปะฐาป": "ััั ะฝะต ะดะตะณะตะฝ ะธะผะฐะฝะดัััาฃ ะฐะฐะฐ?",
    "ะผัาัั": "ััั ะฝะต ะดะตะณะตะฝ ะบัะฐัะฐะฒัะธะบะฟัะฝ ๐",
    "ะผัััั": "ััั ะฝะต ะดะตะณะตะฝ ะบัะฐัะฐะฒัะธะบะฟัะฝ ๐",
    "ะผัาัั ะผัาัั": "ััั ะฝะต ะดะตะณะตะฝ ะบัะฐัะฐะฒัะธะบะฟัะฝ ๐",
}

# Scheduled messages
MORNING_MESSAGES = [
    "๐ ะััะต ัาฑัาะฐะฝ ะตัะบะตะบััาฃ ััััั ะฐัััา! ะาฏะฝัาฃัะท ัำััั ำฉัััะฝ! ๐ช",
    "๐ ะััะต ัาฑัาะฐะฝ ำะนะตะปะดัาฃ ะฑัั ััั ะฐัััา! ะาฏะฝัาฃัะท ะฑะตัะตะบะตะปั ะฑะพะปััะฝ! โจ"
]

NOON_MESSAGE = "๐ ะััะฐะฟ ะพาั ัะฐาััั ะบะตะปะดั! ะัะปัะผ - ัะฐัััะปะผะฐั าะฐะทัะฝะฐ! ๐"
AFTERNOON_MESSAGE = "๐ฌ๐ง าะฐะปะฐะน, ะฑะฐััััะผ, ะฐาัะปััะฝ ััะปัะฝะดะตะณั ะถะฐาฃะฐ ัำฉะทะดะตัะดั ะถะฐััะฐะดัาฃ ะฑะฐ? Remember - practice makes perfect! ๐"
EVENING_MESSAGE = "๐ ะาฏะฝ าะพััััะฝะดััั! ะาฏะณัะฝะณั ะบาฏะฝัาฃ ะฑัะปัะผะผะตะฝ ำฉัััะผะฐ, ำะปะดะต ะฟะฐะนะดะฐััะท ััะฟะตะฝ ำฉัััะผะฐ? Share your progress! ๐ฏ"
SALAUAT_MESSAGE = "ะาฏะณัะฝะณั ัะฐะปะฐัะฐััั าฑะผััะฟะฐะนัา! ะะปะปะฐััะผะผะฐ ัะพะปะปะธ 'ะฐะปั ัะฐะนะนะธะดะธะฝะฐ ะััะฐะผะผะฐะดะธะฝ ัะฐ 'ะฐะปั ะฐะปะธ ัะฐะนะนะธะดะธะฝะฐ ะััะฐะผะผะฐะด"

# Initialize scheduler
scheduler = AsyncIOScheduler(timezone=TIMEZONE)
GROUP_CHAT_ID = "-2385835678" 

# Scheduled messages ะถะฐาฃะฐััั
GROUP_MESSAGES = {
    'morning': [
        "๐ าะฐะนััะปั ัะฐาฃ, ะดะพััะฐั!\nะาฏะณัะฝ ะดะต ะถะฐาฃะฐ ะฑัะปัะผ ะบาฏััะฟ ัาฑั! าะฐะฝะต, ะฑะตะปัะตะฝะดั ะฑะพะปะฐะนัา! ๐ช",
        "๐ ะขะฐาฃ ะฝาฑัะปั, ะบำฉาฃัะป-ะบาฏะน ะบำฉัะตััาฃะบั!\nะาฏะณัะฝ ัะฐาั ะดะฐ าัะทัาัั ัะฐะฟัััะผะฐะปะฐั ะบาฏััะฟ ัาฑั! ๐",
        "๐ ะะฐาฃะฐ ะบาฏะฝ - ะถะฐาฃะฐ ะผาฏะผะบัะฝะดัะบัะตั!\nะัะปัะผะณะต าาฑััะฐั ะฑะพะปะฐะนัา! ๐"
    ],
    'english': [
        "๐ฌ๐ง ะาัะปััะฝ ััะปั ัะฐาััั!\nาำะฝะต, ะดะพััะฐั, ะถะฐาฃะฐ ัำฉะทะดะตั าฏะนัะตะฝะตะนัะบ! ๐ฏ",
        "๐ฌ๐ง English Time!\nะาฏะณัะฝะณั ะถะฐาฃะฐ ัำฉะทะดะตัะดั าฏะนัะตะฝัะณะต ะดะฐะนัะฝััะทะดะฐั ะผะฐ? ๐",
        "๐ฌ๐ง Let's learn English!\nะะฐาฃะฐ ัำฉะทะดะตั ะผะตะฝ ัำฉะท ัััะบะตััะตััะฝ าฏะนัะตะฝะตััะฝ ัะฐาัั ะบะตะปะดั! ๐"
    ],
    'activity': [
        "๐ฏ ะะตะปัะตะฝะดัะปัะบ ัะฐาััั!\nะขะพะฟัะฐ ะบัะผ ะฑะฐั? าะฐะฝะดะฐะน ะถะฐาฃะฐะปัาัะฐั ะฑะฐั? ๐",
        "๐ซ ะะพััะฐั, าะฐะปะฐะนััะทะดะฐั?\nะาฏะณัะฝ าะฐะฝะดะฐะน ะถะตัััััะบัะตัะณะต ะถะตัััาฃัะทะดะตั? ๐",
        "๐ ะขะพะฟ ะฑะตะปัะตะฝะดัะปัะณัะฝ ะฐัััััะฐััะฝ ัะฐาัั!\nะัั-ะฑัััะผัะทะณะต าะพะปะดะฐั ะบำฉััะตัะตะนัะบ! ๐ช"
    ],
    'book': [
        "๐ ะััะฐะฟ ะพาัะฟ ะถะฐัััาฃะดะฐั ะผะฐ? ะาฏะณัะฝ าะฐะฝะดะฐะน ะบััะฐะฟ ะพาัะฟ ะถะฐัััััะทะดะฐั? ๐",
        "๐ ะััะฐะฟ - ะฑัะปัะผ ะฑาฑะปะฐาั! ะาฏะฝะดะต 20 ะผะธะฝัั ะพาั ะฐัาัะปั ะบำฉะฟ ะฑัะปัะผ ะฐะปัาะฐ ะฑะพะปะฐะดั! ๐",
        "๐ ะะพััะฐั, ะฑาฏะณัะฝ าะฐะฝะดะฐะน ะฟะฐะนะดะฐะปั ะบััะฐะฟ ะพาัะฟ ะถะฐัััััะทะดะฐั? ะำฉะปัััาฃัะทะดะตั! ๐"
    ]
}

async def send_group_english_activity(chat_id: int):
    """Send interactive English activity to group"""
    try:
        # ะะฐาฃะฐ ัาฑัะฐา ะถัะฑะตัั
        intro_message = random.choice(GROUP_MESSAGES['english'])
        await bot.send_message(chat_id, intro_message)
        await asyncio.sleep(2)  # ะััะบะตะฝะต าฏะทัะปัั
        await send_english_question(chat_id)
    except Exception as e:
        logger.error(f"Error sending group English activity: {e}")

async def send_group_activity_prompt(chat_id: int):
    """Send activity prompt to group"""
    try:
        message = random.choice(GROUP_MESSAGES['activity'])
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="๐ ะาัะปััะฝ ััะปัะฝ าฏะนัะตะฝั", callback_data="learn_english")],
            [InlineKeyboardButton(text="๐ญ ะัะบัั าะฐะปะดััั", callback_data="leave_feedback")]
        ])
        await bot.send_message(chat_id, message, reply_markup=keyboard)
    except Exception as e:
        logger.error(f"Error sending group activity prompt: {e}")

async def send_book_reminder(chat_id: int):
    """Send book reading reminder"""
    try:
        message = random.choice(GROUP_MESSAGES['book'])
        await bot.send_message(chat_id, message)
    except Exception as e:
        logger.error(f"Error sending book reminder: {e}")

# ะกะฐาะฐั ะฟะตะฝ ะผะธะฝัััั ะถะฐาฃะฐัััะปาะฐะฝ ัะฐาัััะฐัาะฐ ัำะนะบะตั ัะตััะตั
english_schedule = [
    {'hour': 10, 'minute': 20},
    {'hour': 13, 'minute': 0},
    {'hour': 18, 'minute': 30},
    {'hour': 21, 'minute': 0}
]

async def schedule_group_activities(chat_id: int):
    """Schedule group-specific activities"""
    try:
        # ะขะฐาฃาั ัำะปะตะผะดะตัั - 7:00
        scheduler.add_job(
            send_scheduled_message,
            'cron',
            hour=7,
            minute=0,
            args=[chat_id, random.choice(GROUP_MESSAGES['morning'])],
            id=f'group_morning_{chat_id}',
            replace_existing=True
        )

        # ะััะฐะฟ ะพาั ะตัะบะตัััั - 10:00
        scheduler.add_job(
            send_book_reminder,
            'cron',
            hour=10,
            minute=0,
            args=[chat_id],
            id=f'group_book_{chat_id}',
            replace_existing=True
        )

        # ะาัะปััะฝ ััะปั ะฑะตะปัะตะฝะดัะปัะบัะตัั - 16:00
        scheduler.add_job(
            send_scheduled_message,
            'cron',
            hour=10, 
            minute=25,
            args=[chat_id, AFTERNOON_MESSAGE],
            id=f'group_afternoon_{chat_id}',
            replace_existing=True
        )

        # ะาฏะฝ าะพััััะฝะดััั - 20:00
        scheduler.add_job(
            send_scheduled_message,
            'cron',
            hour=20,
            minute=0,
            args=[chat_id, EVENING_MESSAGE],
            id=f'group_evening_{chat_id}',
            replace_existing=True
        )

        # ะกะฐะปะฐัะฐั ะตัะบะตัััั - 22:00
        scheduler.add_job(
            send_scheduled_message,
            'cron',
            hour=22,
            minute=50,
            args=[chat_id, SALAUAT_MESSAGE],
            id=f'group_salauat_{chat_id}',
            replace_existing=True
        )

        # ะาัะปััะฝ ััะปั ะฑะตะปัะตะฝะดัะปัะบัะตัั
        for schedule in english_schedule:
            scheduler.add_job(
                send_group_english_activity,
                'cron',
                hour=schedule['hour'],
                minute=schedule['minute'],
                args=[chat_id],
                id=f'group_english_{schedule["hour"]}_{schedule["minute"]}_{chat_id}',
                replace_existing=True
            )

        logger.info(f"Group activities scheduled for chat {chat_id}")
    except Exception as e:
        logger.error(f"Error scheduling group activities: {e}")

def get_english_menu() -> InlineKeyboardMarkup:
    """Create main menu keyboard"""
    keyboard = [
        [InlineKeyboardButton(text="๐ ะาัะปััะฝ ััะปัะฝ าฏะนัะตะฝั", callback_data="learn_english")],
        [InlineKeyboardButton(text="๐ ะะตะฝัาฃ ะถะตัััััะบัะตััะผ", callback_data="my_progress")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

async def send_english_question(chat_id: int) -> None:
    """Send English learning question to chat"""
    try:
        # Get previously asked questions for this chat
        asked_questions = user_progress.get(chat_id, {}).get("asked_questions", [])
        
        # Filter out questions that haven't been asked yet
        available_questions = [q for q in ENGLISH_QUESTIONS if q["id"] not in asked_questions]
        
        # If all questions have been asked, reset the list
        if not available_questions:
            asked_questions = []
            available_questions = ENGLISH_QUESTIONS
        
        # Select a random question
        question = random.choice(available_questions)
        
        # Initialize or update user progress
        if chat_id not in user_progress:
            user_progress[chat_id] = {
                "asked_questions": [],
                "current_question": None,
                "correct_answers": 0,
                "questions_answered": 0
            }
        
        # Update current question and asked questions
        user_progress[chat_id]["current_question"] = question
        user_progress[chat_id]["asked_questions"] = asked_questions + [question["id"]]
        
        # Create keyboard with options
        options_keyboard = []
        for option in question["options"]:
            callback_data = f"answer_{question['id']}_{option}"
            options_keyboard.append([InlineKeyboardButton(text=option, callback_data=callback_data)])
        
        markup = InlineKeyboardMarkup(inline_keyboard=options_keyboard)
        
        try:
            await bot.send_photo(
                chat_id=chat_id,
                photo=question["image_url"],
                caption=f"โ {question['question']}",
                reply_markup=markup
            )
            logger.info(f"Question {question['id']} sent successfully to chat {chat_id}")
        except Exception as photo_error:
            logger.error(f"Error sending photo: {photo_error}")
            await bot.send_message(
                chat_id=chat_id,
                text=f"โ {question['question']}",
                reply_markup=markup
            )
    except Exception as e:
        logger.error(f"Error in send_english_question: {e}")
        await bot.send_message(
            chat_id=chat_id,
            text="าะฐัะตะปัะบ ะพััะฝ ะฐะปะดั. าะฐะนัะฐะดะฐะฝ ะบำฉััาฃัะท. /start"
        )

@dp.callback_query(lambda c: c.data == "learn_english")
async def start_learning(callback_query: CallbackQuery):
    """Handle learn English button"""
    try:
        chat_id = callback_query.message.chat.id
        await callback_query.answer()
        await send_english_question(chat_id)
    except Exception as e:
        logger.error(f"Error in start_learning: {e}")
        await callback_query.message.answer("าะฐัะตะปัะบ ะพััะฝ ะฐะปะดั. าะฐะนัะฐะดะฐะฝ ะบำฉััาฃัะท.")

@dp.callback_query(lambda c: c.data.startswith("answer_"))
async def process_answer(callback_query: CallbackQuery):
    """Handle answer selection"""
    try:
        chat_id = callback_query.message.chat.id
        _, question_id, selected_answer = callback_query.data.split("_")
        
        # Initialize progress if not exists
        if chat_id not in user_progress:
            user_progress[chat_id] = {
                "asked_questions": [],
                "current_question": None,
                "correct_answers": 0,
                "questions_answered": 0,
                "last_question_message": None  # Add this to track the last question message
            }
        
        current_question = user_progress[chat_id].get("current_question")
        
        if current_question and current_question["id"] == question_id:
            # Remove the old keyboard
            await callback_query.message.edit_reply_markup(reply_markup=None)
            
            # Store result message for later deletion
            if selected_answer == current_question["correct"]:
                user_progress[chat_id]["correct_answers"] += 1
                result_message = await callback_query.message.reply("๐ ะาฑััั! / Correct!")
            else:
                result_message = await callback_query.message.reply(
                    f"โ าะฐัะต! ะาฑััั ะถะฐัะฐะฟ: {current_question['correct']}"
                )
            
            user_progress[chat_id]["questions_answered"] += 1
            
            # Send result message with next question button
            result_text = (
                f"โ ะาฑััั ะถะฐัะฐะฟัะฐั: {user_progress[chat_id]['correct_answers']}\n"
                f"๐ ะะฐัะปัา ะถะฐัะฐะฟัะฐั: {user_progress[chat_id]['questions_answered']}"
            )
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="๐ ะะตะปะตัั ัาฑัะฐา", callback_data="next_question")],
                [InlineKeyboardButton(text="๐ ะะฐััั ะผำะทัั", callback_data="main_menu")]
            ])
            
            status_message = await callback_query.message.reply(result_text, reply_markup=keyboard)
            
            # Store messages to be deleted when moving to next question
            user_progress[chat_id]["last_question_message"] = {
                "question": callback_query.message,
                "result": result_message,
                "status": status_message
            }
        
    except Exception as e:
        logger.error(f"Error in process_answer: {e}")
        await callback_query.message.reply("าะฐัะตะปัะบ ะพััะฝ ะฐะปะดั. าะฐะนัะฐะดะฐะฝ ะบำฉััาฃัะท.")

@dp.callback_query(lambda c: c.data == "next_question")
async def next_question(callback_query: CallbackQuery):
    """Handle next question button"""
    try:
        await callback_query.answer()
        chat_id = callback_query.message.chat.id
        
        # Delete previous messages if they exist
        if chat_id in user_progress and user_progress[chat_id].get("last_question_message"):
            last_messages = user_progress[chat_id]["last_question_message"]
            try:
                # Delete previous question, result, and status messages
                await last_messages["question"].delete()
                await last_messages["result"].delete()
                await last_messages["status"].delete()
            except Exception as delete_error:
                logger.error(f"Error deleting messages: {delete_error}")
            
            # Clear the stored messages
            user_progress[chat_id]["last_question_message"] = None
        
        # Send new question
        await send_english_question(chat_id)
        
    except Exception as e:
        logger.error(f"Error in next_question: {e}")
        await callback_query.message.answer("าะฐัะตะปัะบ ะพััะฝ ะฐะปะดั. าะฐะนัะฐะดะฐะฝ ะบำฉััาฃัะท.")

@dp.callback_query(lambda c: c.data == "my_progress")
async def show_progress(callback_query: CallbackQuery):
    """Show user's learning progress"""
    try:
        chat_id = callback_query.message.chat.id
        
        if chat_id in user_progress:
            correct = user_progress[chat_id].get("correct_answers", 0)
            total = user_progress[chat_id].get("questions_answered", 0)
            percentage = (correct / total * 100) if total > 0 else 0
            
            progress_text = (
                f"๐ ะกัะทะดัาฃ ะถะตัััััะบัะตััาฃัะท:\n\n"
                f"โ ะาฑััั ะถะฐัะฐะฟัะฐั: {correct}\n"
                f"๐ ะะฐัะปัา ะถะฐัะฐะฟัะฐั: {total}\n"
                f"๐ ะะฐะนัะทะดัา ะบำฉััะตัะบัั: {percentage:.1f}%"
            )
            
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="๐ ะะฐััั ะผำะทัั", callback_data="main_menu")]
            ])
            
            await callback_query.message.answer(progress_text, reply_markup=keyboard)
        else:
            await callback_query.answer(
                "ะกัะท ำะปั ัะตัั ัะฐะฟัััาะฐะฝ ะถะพาััะท.\n"
                "You haven't taken any tests yet."
            )
    except Exception as e:
        logger.error(f"Error in show_progress: {e}")
        await callback_query.message.answer("าะฐัะตะปัะบ ะพััะฝ ะฐะปะดั. าะฐะนัะฐะดะฐะฝ ะบำฉััาฃัะท.")

# start_command ััะฝะบัะธัััะฝ ะถะฐาฃะฐััั
async def send_scheduled_message(chat_id: int, message: str):
    """Send scheduled message to user or group with appropriate keyboard"""
    try:
        # Determine chat type and set appropriate keyboard
        is_group = chat_id in group_ids
        keyboard = None
        
        if is_group:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="๐ ะาัะปััะฝ ััะปัะฝ าฏะนัะตะฝั", callback_data="learn_english")]
            ])
        else:
            keyboard = get_english_menu()
            
        await bot.send_message(chat_id, message, reply_markup=keyboard)
        logger.info(f"Scheduled message sent to {'group' if is_group else 'private'} chat {chat_id}")
    except Exception as e:
        logger.error(f"Error sending scheduled message to {chat_id}: {e}")
        # Remove from tracking if message fails
        if chat_id in active_users:
            active_users.discard(chat_id)
        if chat_id in group_ids:
            group_ids.discard(chat_id)


async def morning_reminder(chat_id: int):
    """Send morning reminder"""
    message = random.choice(MORNING_MESSAGES)
    await send_scheduled_message(chat_id, message)

async def schedule_reminders(chat_id: int):
    """Schedule all reminders for a user or group"""
    try:
        is_group = chat_id in group_ids
        
        # Common scheduling for both private and group chats
        scheduler_jobs = [
            # Morning reminder - 7:00
            {
                'func': send_scheduled_message,
                'hour': 7,
                'minute': 0,
                'args': [chat_id, random.choice(MORNING_MESSAGES if not is_group else GROUP_MESSAGES['morning'])],
                'id': f'morning_{chat_id}'
            },
            # Noon message - 10:00
            {
                'func': send_scheduled_message,
                'hour': 10,
                'minute': 0,
                'args': [chat_id, NOON_MESSAGE if not is_group else random.choice(GROUP_MESSAGES['book'])],
                'id': f'noon_{chat_id}'
            },
            # Afternoon message - 16:00
            {
                'func': send_scheduled_message,
                'hour': 10,
                'minute': 25,
                'args': [chat_id, AFTERNOON_MESSAGE if not is_group else random.choice(GROUP_MESSAGES['english'])],
                'id': f'afternoon_{chat_id}'
            },
            # Evening message - 20:00
            {
                'func': send_scheduled_message,
                'hour': 20,
                'minute': 0,
                'args': [chat_id, EVENING_MESSAGE if not is_group else random.choice(GROUP_MESSAGES['activity'])],
                'id': f'evening_{chat_id}'
            },
            # Salauat message - 22:00
            {
                'func': send_scheduled_message,
                'hour': 22,
                'minute': 50,
                'args': [chat_id, SALAUAT_MESSAGE],
                'id': f'salauat_{chat_id}'
            }
        ]

        # Schedule all jobs
        for job in scheduler_jobs:
            scheduler.add_job(
                job['func'],
                'cron',
                hour=job['hour'],
                minute=job['minute'],
                args=job['args'],
                id=job['id'],
                replace_existing=True
            )

        # Schedule English lessons at specific times
        for schedule in english_schedule:
            job_id = f'english_{schedule["hour"]}_{schedule["minute"]}_{chat_id}'
            if is_group:
                scheduler.add_job(
                    send_group_english_activity,
                    'cron',
                    hour=schedule['hour'],
                    minute=schedule['minute'],
                    args=[chat_id],
                    id=job_id,
                    replace_existing=True
                )
            else:
                scheduler.add_job(
                    send_english_question,
                    'cron',
                    hour=schedule['hour'],
                    minute=schedule['minute'],
                    args=[chat_id],
                    id=job_id,
                    replace_existing=True
                )

        if not scheduler.running:
            scheduler.start()
        
        logger.info(f"Reminders scheduled for {'group' if is_group else 'private'} chat {chat_id}")
    except Exception as e:
        logger.error(f"Error scheduling reminders for {chat_id}: {e}")


# ะะฐาฃะฐ callback handler าะพัั
@dp.callback_query(lambda c: c.data == "leave_feedback")
async def handle_feedback(callback_query: CallbackQuery):
    """Handle feedback button press"""
    try:
        await callback_query.answer()
        await callback_query.message.reply(
            "๐ญ ะขะพะฟัั ะถะฐาัะฐััั าฏััะฝ ะฟัะบัััาฃัะทะดั าะฐะปะดัััาฃัะท!\n"
            "าะฐะฝะดะฐะน ัะฐาัััะฟัะฐั าัะทัาัััะฐะดั? าะฐะฝะดะฐะน ะถะฐัััาัะปะฐั าะพัาัะผัะท ะบะตะปะตะดั?"
        )
    except Exception as e:
        logger.error(f"Error handling feedback: {e}")

# Add these functions
def save_group_ids():
    with open('group_ids.json', 'w') as f:
        json.dump(list(group_ids), f)

def load_group_ids():
    try:
        with open('group_ids.json', 'r') as f:
            return set(json.load(f))
    except FileNotFoundError:
        return set()

# Update start command to use the same scheduling system
@dp.message(CommandStart())
async def start_command(message: Message):
    """Handle /start command"""
    try:
        chat_id = message.chat.id
        
        if message.chat.type in ['group', 'supergroup']:
            group_ids.add(chat_id)
            save_group_ids()
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="๐ ะาัะปััะฝ ััะปัะฝ าฏะนัะตะฝั", callback_data="learn_english")]
            ])
            await message.reply(
                "ะััะฐะปะฐัะผะฐาะฐะปะตะนะบัะผ, ัะพะฟ ะผาฏัะตะปะตัั! ๐\n\n"
                "ะะตะฝ ััะทะดะตัะดัาฃ ะบำฉะผะตะบััะปะตััาฃัะทะฑัะฝ!\n"
                "๐ฏ ะะตะฝัาฃ ะผาฏะผะบัะฝะดัะบัะตััะผ:\n"
                "- ะาฏะฝะดะตะปัะบัั ะฐาัะปััะฝ ััะปั ัะฐะฑะฐาัะฐัั\n"
                "- ะขะพะฟ ะฑะตะปัะตะฝะดัะปัะณัะฝ ะฐัััััั\n"
                "- าัะทัาัั ัะฐะฟัััะผะฐะปะฐั\n"
                "- ะะฐะนะดะฐะปั ะตัะบะตัััะปะตั\n\n"
                "ะขะพะฟัะฐ ะฑะตะปัะตะฝะดั ะฑะพะปัาฃัะทะดะฐั! ๐",
                reply_markup=keyboard
            )
        else:
            active_users.add(chat_id)
            await message.reply(
                "ะััะฐะปะฐัะผะฐาะฐะปะตะนะบัะผ! ๐\n"
                "ะะตะฝ ััะทะดัาฃ ะบำฉะผะตะบััาฃัะทะฑัะฝ. ะกาฑัะฐาัะฐััาฃัะทาะฐ ะถะฐัะฐะฟ ะฑะตััะฟ, "
                "ะบาฏะฝะดะตะปัะบัั ะตัะบะตัััะปะตั ะถะฐัะฐะนะผัะฝ!\n\n"
                "ะขำฉะผะตะฝะดะตะณั ะฑะฐัััะผะฐะปะฐัะดั ะฑะฐััะฟ, ะฐาัะปััะฝ ััะปัะฝ าฏะนัะตะฝะต ะฐะปะฐััะท!",
                reply_markup=get_english_menu()
            )
        
        # Schedule reminders for both private and group chats
        await schedule_reminders(chat_id)
        logger.info(f"Bot started in {'group' if chat_id in group_ids else 'private'} chat: {chat_id}")
    except Exception as e:
        logger.error(f"Error in start_command: {e}")
        await message.reply("าะฐัะตะปัะบ ะพััะฝ ะฐะปะดั. าะฐะนัะฐะดะฐะฝ ำัะตะบะตััะตะฝัะฟ ะบำฉััาฃัะท.")
        
@dp.message()
@handle_exceptions
async def handle_messages(message: Message):
    """Handle all incoming messages with rate limiting"""
    try:
        # Check rate limiting
        if is_rate_limited(message.from_user.id):
            await message.answer("ะขัะผ ะถะธั ัะฐะฑะฐัะปะฐะผะฐ ะถัะฑะตัะดัาฃัะท. ะััะฐะท ะบาฏัะต ัาฑััาฃัะท.")
            return

        # Check if message has text
        if not message.text:
            return

        # Convert message to lowercase for case-insensitive matching
        text = message.text.lower().strip()

        # Check if the message is in BASIC_RESPONSES
        if text in BASIC_RESPONSES:
            try:
                # Create appropriate keyboard based on chat type
                keyboard = (
                    get_english_menu() 
                    if message.chat.type == 'private'
                    else InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(
                            text="๐ ะาัะปััะฝ ััะปัะฝ าฏะนัะตะฝั",
                            callback_data="learn_english"
                        )]
                    ])
                )
                
                # Send response with keyboard
                await message.answer(
                    BASIC_RESPONSES[text],
                    reply_markup=keyboard
                )
                
                # Update tracking
                if message.chat.type == 'private':
                    active_users.add(message.chat.id)
                elif message.chat.type in ['group', 'supergroup']:
                    group_ids.add(message.chat.id)
                    
                logger.info(f"Successfully responded to message '{text}' in chat {message.chat.id}")
                
            except Exception as e:
                logger.error(f"Error sending basic response for '{text}': {e}")
                raise  # Let the decorator handle the error

    except Exception as e:
        logger.error(f"Error in handle_messages: {e}")
        # The decorator will handle sending the error message to the user


# Add proper cleanup on shutdown
async def shutdown(dispatcher: Dispatcher):
    """Cleanup resources on shutdown"""
    try:
        if scheduler.running:
            scheduler.shutdown(wait=True)
        await bot.session.close()
        logger.info("Bot shut down successfully")
    except Exception as e:
        logger.error(f"Error during shutdown: {e}")

# Update main function with proper shutdown handling
async def main() -> None:
    """Main function to start the bot with proper error handling"""
    try:

        global group_ids
        group_ids = load_group_ids()
       

        # Start the scheduler
        if not scheduler.running:
            scheduler.start()
            logger.info(f"Loaded group IDs: {group_ids}")

        # Schedule reminders for all known groups
            for group_id in group_ids:
                await schedule_reminders(group_id)
                logger.info(f"Scheduled reminders for group: {group_id}")
        # Set up commands
        commands_list = [
            types.BotCommand(command="start", description="ะะฐััะฐั / Start the bot"),
            types.BotCommand(command="help", description="ะำฉะผะตะบ / Help information"),
            types.BotCommand(command="schedule", description="ะะตััะต / Show schedule"),
        ]
        await bot.set_my_commands(commands_list)
        
        # Start polling with proper error handling
        logger.info("Bot started successfully")
        await dp.start_polling(bot)
    except Exception as e:
        logger.error(f"Critical error in main function: {e}", exc_info=True)
    finally:
        await shutdown(dp)


@dp.message(Command("check_schedules"))
async def check_schedules(message: Message):
    try:
        chat_id = message.chat.id
        jobs = scheduler.get_jobs()
        schedules = [f"Job: {job.id}, Next run: {job.next_run_time}" for job in jobs if str(chat_id) in job.id]
        
        if schedules:
            await message.reply("\n".join(schedules))
        else:
            await message.reply("No scheduled messages found for this chat")
    except Exception as e:
        logger.error(f"Error checking schedules: {e}")

@dp.message(Command('help'))
async def help_command(message: Message):
    """Handle /help command"""
    help_text = (
        "๐ค *ะะตะฝัาฃ ะผาฏะผะบัะฝะดัะบัะตััะผ:*\n\n"
        "๐น /start - ะะพััั ััะบะต าะพัั\n"
        "๐น /help - ะำฉะผะตะบ ะฐะปั\n"
        "๐น /schedule - ะฅะฐะฑะฐัะปะฐะผะฐะปะฐั ะบะตััะตััะฝ าะฐัะฐั\n\n"
        "๐ ะาัะปััะฝ ััะปัะฝ าฏะนัะตะฝั ะผาฏะผะบัะฝะดัะณัะฝ ะฟะฐะนะดะฐะปะฐะฝั าฏััะฝ ัะธัััั ะฑะฐัััะผะฐะฝั ะฑะฐััาฃัะท.\n"
        "๐ ะัะบะตัััะปะตั ะบาฏะฝ ะฑะพะนั ะฑะตะปะณัะปะตะฝะณะตะฝ ัะฐาัััะฐ ะถัะฑะตััะปะตะดั.\n"
        "โ ะำััะฝะดัะบ ัาฑัะฐาัะฐัาะฐ ะฐะฒัะพะผะฐััั ัาฏัะดะต ะถะฐัะฐะฟ ะฑะตัะตะผัะฝ.\n\n"
        "๐ฑ ะขะฐะฟัััะผะฐะปะฐัะดั ะพััะฝะดะฐะฟ, ะฑัะปัะผัาฃัะทะดั ะถะตััะปะดัััาฃัะท!"
    )
    try:
        # Create appropriate keyboard based on chat type
        if message.chat.type == 'private':
            keyboard = get_english_menu()
        else:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="๐ ะาัะปััะฝ ััะปัะฝ าฏะนัะตะฝั", callback_data="learn_english")]
            ])
            
        await message.answer(help_text, reply_markup=keyboard, parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Error in help_command: {e}")
        await message.answer("าะฐัะตะปัะบ ะพััะฝ ะฐะปะดั. าะฐะนัะฐะดะฐะฝ ะบำฉััาฃัะท.")

@dp.message(Command('schedule'))
async def schedule_command(message: Message):
    """Handle /schedule command"""
    schedule_text = (
        "๐ *ะาฏะฝะดะตะปัะบัั ัะฐะฑะฐัะปะฐะผะฐะปะฐั ะบะตััะตัั:*\n\n"
        "๐ 07:00 - ะขะฐาฃาั ะตัะบะตััั\n"
        "๐ 10:00 - ะััะฐะฟ ะพาั ัะฐาััั\n"
        "๐ฌ๐ง 13:00 - ะาัะปััะฝ ััะปั ัะฐะฑะฐาั\n"
        "๐ฌ๐ง 16:00 - ะาัะปััะฝ ััะปั ัะฐะฑะฐาั\n"
        "๐ฌ๐ง 17:00 - ะาัะปััะฝ ััะปั ัะฐะฑะฐาั\n"
        "๐ 20:00 - ะาฏะฝ าะพััััะฝะดััั\n"
        "๐คฒ 22:50 - ะกะฐะปะฐัะฐั\n\n"
        "๐ ะะฐัะปัา ะตัะบะตัััะปะตั *ะฐะฒัะพะผะฐััั ัาฏัะดะต* ะถัะฑะตััะปะตะดั."
    )
    try:
        # Create appropriate keyboard based on chat type
        if message.chat.type == 'private':
            keyboard = get_english_menu()
        else:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="๐ ะาัะปััะฝ ััะปัะฝ าฏะนัะตะฝั", callback_data="learn_english")]
            ])
            
        await message.answer(schedule_text, reply_markup=keyboard, parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Error in schedule_command: {e}")
        await message.answer("าะฐัะตะปัะบ ะพััะฝ ะฐะปะดั. าะฐะนัะฐะดะฐะฝ ะบำฉััาฃัะท.")

# Ensure the bot is run only if this script is executed directly
if __name__ == "__main__":
    asyncio.run(main())
